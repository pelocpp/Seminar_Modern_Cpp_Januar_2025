// =========================================

Modern C++

Peter Loos  // "Du"

C/C++ , Java, C#,  JavaScript, Mobile Progr. (Java)

Back-to-the-Roots: C++

=============================================

2  Tools:

== Visual Studio 2022 Community

== Github.com

https://github.com/pelocpp

== Beispiele
== Erläuterungen

=======================================

Was sind meine Erwartungen ???

== Überblick
== Muss C++ lesen / verstehen können
== Was MUSS DRIN SEIN 
== Was kann ich außer C/C++ noch (Querbezüge)
== Nicht: Referent // Eher:  Verständnis
== Multithreading

Was bringe ich mit : Agenda

=======================================

2 Aktionen:

Agenda: Roter Faden

a) Github

b) Quellcode:

   Program.cpp  ==> Unterprogramm

=====================================

Referenz:  C++

=> Im Hintergrund:  Es wird die Adresse eines Objekts betrachtet

=> Eine Referenz bezieht sich auf ein Objekt,
   das ich unter seinem NAMEN anspreche.

Es gibt auch Objekt OHNE Namen:  a + b

   Temporäre Objekte, anonyme Objekt

   Zwischenergebnisse // Ausdrücke

const& kann anonyme Objekte weiterreichen.

====> Performanz  // KEINE KOPIEN

Ab C++ 11:

Es gibt nun 2 ARTEN von Referenzen:

std::string&   ===> Für Objekte MIT NAMEN
std::string&&  ===> Für Objekte OHNE NAMEN // tmp.Objekte

====================================================

Wiederholung: Rule of Three

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Markdown/RuleOfThree.md

====================================================

Why ??????????????????????????????????????????


:-: .... 460   // wird jetzt gelöscht
:-: .... 2A0   // liegt im Vektor

2 Objekte waren nötig, um "ein" Objekt im Vektor
ablegen zu können.

Lösung: 

C++ 11:  Move-Semantik

:-: .... 460


// =========================================

Java, C#:   Kennen dieses Problem nicht:

            new // rein referenz-basiert // NUR: HEAP

C++:        i)  Stack-basiert: Ein Objekt liegt am STACK
            ii) Referenz-basiert


===========================================

Why ................................

===========================================

Initialisierung

Einheitliche Initialisierung // Uniform Initialization

"Brace" Initialization

// local variable
int n = 123;

int n{ 123 };

        double d1 = ival;     // Compiles
00007FF619B61620  cvtsi2sd    xmm0,dword ptr [ival]  
00007FF619B61625  movsd       mmword ptr [d1],xmm0  

        double d2 = 123;      // Compiles
00007FF619B6162A  movsd       xmm0,mmword ptr [__real@405ec00000000000 (07FF619D750A8h)]  
00007FF619B61632  movsd       mmword ptr [d2],xmm0  

// =================================================

Lambda: 

Historisch:

a) C-Funktion

b) Aufrufbares Objekt

c) Klassen für aufrufbare Objekte können innerhalb von 
   Funktionen / Methoden definiert werden.

   Why ????  ===> So ist ein Lambda in C++ realisiert.

Bemerkung / Achtung:

Lambda: "Ist eine Funktion ohne Namen" 

Ist nicht falsch :)

Exakt: Lambda: Ist ein Objekt !!!!!!!!!!!!!!!!!!

Hinter den Kulissen:

Ein Lambda ist ein Objekt vom Typ einer aufrufbaren Klasse.

Diese wird versteckt in der aktuellen Funktion definiert.

Der "Inhalt der Lambda-Funktion" wird dem Aufruf-Operator (operator())
der versteckten Klasse zugeordnet.

In der Voreinstellung ist diese Methode / operator()
als const definiert.

Mit 'mutable' kann man die const-ness entfernen.

// ===================================

Ein Lambda ist ein Objekt :) einer anonymen Klasse.

Was besitzen Objekte ==> Instanzvariablen

Beispiel:

123
124
125



15:35 


